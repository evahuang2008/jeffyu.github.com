--- 
layout: post
title: !binary |
  W0NYRl1DWEbkuK1EeW5hbWljUHJveHnmqKHlvI/nmoTlupTnlKg=

published: true
meta: 
  spaces_a43755b404d273dfcedbd14ccb4f51ab_permalink: http://cid-04001c604af3f011.users.api.live.net/Users(288261576051650577)/Blogs('4001C604AF3F011!102')/Entries('4001C604AF3F011!464')?authkey=X13wC75MXT0%24
  _searchme: "1"
  _edit_last: "1"
  _efficient_related_posts: "a:8:{i:0;a:4:{s:2:\"ID\";s:1:\"6\";s:10:\"post_title\";s:53:\"[CXF]CXF\xE4\xB8\xAD\xE7\x9A\x84\xE4\xB8\xA4\xE4\xB8\xAA\xE6\xA6\x82\xE5\xBF\xB5:Invoker & PhaseInterceptor\";s:7:\"matches\";s:1:\"2\";s:9:\"permalink\";s:121:\"http://jeff.familyyu.net/2007/08/26/cxfcxf%e4%b8%ad%e7%9a%84%e4%b8%a4%e4%b8%aa%e6%a6%82%e5%bf%b5invoker-phaseinterceptor/\";}i:1;a:4:{s:2:\"ID\";s:2:\"10\";s:10:\"post_title\";s:61:\"[CXF]CXF\xE5\xBD\x93\xE4\xB8\xAD\xE7\x9A\x84Configuration -- Spring2.0\xE5\x8F\xAF\xE6\x89\xA9\xE5\xB1\x95XML\xE9\x85\x8D\xE7\xBD\xAE\";s:7:\"matches\";s:1:\"2\";s:9:\"permalink\";s:141:\"http://jeff.familyyu.net/2007/08/23/cxfcxf%e5%bd%93%e4%b8%ad%e7%9a%84configuration-spring2-0%e5%8f%af%e6%89%a9%e5%b1%95xml%e9%85%8d%e7%bd%ae/\";}i:2;a:4:{s:2:\"ID\";s:2:\"23\";s:10:\"post_title\";s:46:\"[CXF]CXF\xE4\xB8\xADCollection Parameter\xE6\xA8\xA1\xE5\xBC\x8F\xE7\x9A\x84\xE5\xBA\x94\xE7\x94\xA8\";s:7:\"matches\";s:1:\"2\";s:9:\"permalink\";s:117:\"http://jeff.familyyu.net/2007/07/14/cxfcxf%e4%b8%adcollection-parameter%e6%a8%a1%e5%bc%8f%e7%9a%84%e5%ba%94%e7%94%a8/\";}i:3;a:4:{s:2:\"ID\";s:2:\"22\";s:10:\"post_title\";s:42:\"[CXF]CXF\xE4\xB8\xAD\xE7\x9A\x84AbstractFactory\xE6\xA8\xA1\xE5\xBC\x8F\xE5\xBA\x94\xE7\x94\xA8.\";s:7:\"matches\";s:1:\"2\";s:9:\"permalink\";s:112:\"http://jeff.familyyu.net/2007/07/14/cxfcxf%e4%b8%ad%e7%9a%84abstractfactory%e6%a8%a1%e5%bc%8f%e5%ba%94%e7%94%a8/\";}i:4;a:4:{s:2:\"ID\";s:2:\"20\";s:10:\"post_title\";s:34:\"[CXF]CXF\xE4\xB8\xAD\xE7\x9A\x84Observer\xE6\xA8\xA1\xE5\xBC\x8F\xE5\xBA\x94\xE7\x94\xA8\";s:7:\"matches\";s:1:\"2\";s:9:\"permalink\";s:105:\"http://jeff.familyyu.net/2007/07/12/cxfcxf%e4%b8%ad%e7%9a%84observer%e6%a8%a1%e5%bc%8f%e5%ba%94%e7%94%a8/\";}i:5;a:4:{s:2:\"ID\";s:3:\"272\";s:10:\"post_title\";s:40:\"Apache CXF Web Service Development book.\";s:7:\"matches\";s:1:\"1\";s:9:\"permalink\";s:76:\"http://jeff.familyyu.net/2010/02/20/apache-cxf-web-service-development-book/\";}i:6;a:4:{s:2:\"ID\";s:3:\"167\";s:10:\"post_title\";s:30:\"IMS rolled out its 0.1 version\";s:7:\"matches\";s:1:\"1\";s:9:\"permalink\";s:67:\"http://jeff.familyyu.net/2007/11/13/ims-rolled-out-its-0-1-version/\";}i:7;a:4:{s:2:\"ID\";s:3:\"146\";s:10:\"post_title\";s:29:\"CXF ServiceInfo Model diagram\";s:7:\"matches\";s:1:\"1\";s:9:\"permalink\";s:66:\"http://jeff.familyyu.net/2007/09/06/cxf-serviceinfo-model-diagram/\";}}"
  _relation_threshold: "1"
tags: 
- Chinese
- CXF
- Design Patterns
- SOA
- Web Service
type: post
status: publish
---
<div id="msgcns!4001C604AF3F011!464" class="bvMsg">在讲Dynamic Proxy模式之前,可能需要理解下<a href="http://www.dofactory.com/Patterns/PatternProxy.aspx">Proxy模式</a>, 经典的Proxy模式里,我们一般需要建立个Proxy的类来包含真正的实现类,而Client端调用的时候,则是去调用Proxy的类,这样Proxy类里就可以控制权限等问题.
在CXF当中用的是JDK自带的Dynamic Proxy,为什么叫Dynamic Proxy呢,因为他在编译的时候,并没有那个Proxy类,而是在运行时期生成一个Proxy类.
在看CXF代码应用Dynamic Proxy之前,来看一个简单的实现.&nbsp;

Interface类：
public interface HelloInterface {
public void sayHi(String name) throws Exception;
}

Impl类:
public class HelloInterfaceImpl implements HelloInterface {
public void sayHi(String name) throws Exception {
System.out.println("This is real HelloInterfaceImpl");
System.out.println("You Inovke sayHi with name : [" + name +"]");
}
}

Proxy的实现..
public class HelloInterfaceProxy implements InvocationHandler {
private Object object;
public static Object getInstance(Object o) {
return Proxy.newProxyInstance(o.getClass().getClassLoader(), o.getClass().getInterfaces(), new HelloInterfaceProxy(o));
}
private HelloInterfaceProxy(Object o) {
object = o;
}
public Object invoke(Object arg0, Method method, Object[] arg2) throws Throwable {
System.out.println("It was interceptored by the HelloInterfaceProxy class firstly");
return method.invoke(object, arg2);
}
}

Client端的调用:
HelloInterfaceImpl impl = new HelloInterfaceImpl();
HelloInterface hello = (HelloInterface)HelloInterfaceProxy.getInstance(impl);
hello.sayHi("Jeff");
运行结果:
It was interceptored by the HelloInterfaceProxy class firstly
This is real HelloInterfaceImpl
You Inovke sayHi with name : [Jeff]

在Client端的调用程序中,我们所获得的hello是一个HelloInterfaceProxy的类,并不是指到真正的HelloInterfaceImpl类.
这里,我们并没有一个真正的HelloInterfaceProxy的类,因为他是在运行时期产生的,所以我们把这个模式叫做Dynamic Proxy.

在CXF当中,实现InvocationHandler的类是: ClientProxy
Interface呢,就是SEI: 比如说是: Greeter.
真正的实现类,是GreeterImpl.
我们在客户端所获取到的Greeter实现,实际上是个GreeterProxy对象.

下面这是获取到客户端实现:
SOAPService ss = new SOAPService(wsdlURL, SERVICE_NAME);
Greeter port = ss.getSoapPort();

</div>
