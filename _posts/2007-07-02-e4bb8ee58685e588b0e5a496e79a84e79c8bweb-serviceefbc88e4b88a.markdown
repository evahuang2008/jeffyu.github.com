---
date: '2007-07-02 18:13:38'
layout: post
slug: '%e4%bb%8e%e5%86%85%e5%88%b0%e5%a4%96%e7%9a%84%e7%9c%8bweb-service%ef%bc%88%e4%b8%8a'
status: publish
title: 从内到外的看Web Service（上)
wordpress_id: '25'
categories:
- Web Service
---

我之前是做企业应用的,从一毕业就开始做..那么,当你刚接触web service的时候,你可能会有一头雾水的感觉,我当时很渴望说有个人能跟我说下他们之间的联系,是怎么关联起来的. 下面我尝试着来讲讲，前段时间我一兄弟也叫我说,跟他说说我做的是什么东西.  
  
先从Servlet说起. 比如说我写了一个servlet,然后启动了servlet container (tomcat),那么，你就可以通过这个servlet的url来访问这个servlet. 这里面呢,其实就建立了一个程序的调用,或者说资源的共享方式. 比如说,我的这个servlet提供了资料数据库. 那么,当我在另外一台机器通过浏览器输入这个servlet的url只要带上正确的用户名和密码,就可以获取到资料.至于获取资料的逻辑,我们需要在servlet方法的doPost() 或者是 doGet()的方法里面完成,然后通过HttpResponse把数据返回给客户端. 在这里,我们通过了HttpServletRequest/HttpServletResponse来实现了数据的传输. 在Web Service的世界里,有个Transport的概念.我们这个所用的就是HTTP Transport,还有JMS Transport.  
  
JAX-WS的前身,叫做JAX-RPC,也就是Java API XML Remote Procedure Call. 就是说用xml的方式来进行远程方法调用. 怎么理解呢？ 我们先来看看著名的Struts是怎么来实现方法的调用.   
  
1. 我们会有个struts-config.xml来配置那个url是具体调用那个Java的方法.那么当我们收到这个url的时候呢,我们就根据这个mapping来找到他说要调用的方法,然后把参数传给这个方法,运行完，再通过HttpServletResponse传给客户端.    
2. 那么在xml-rpc的世界里,我们并不存在这样的一个xml来对应mapping关系,而且,一般对于web service来说,他就提供一个通过的servlet url,比如说(http://localhost:9000),至于什么样的消息该调用什么样的方法,都没有一个配置文件来描述. 再来回顾下我们刚刚说讲的servlet例子,我们刚刚用Http Transport都是以Request过去的是一个string,回来的也是一个String. 在web-service的世界里,我们用的都是xml. 也就是说我从Http Request发过去的是一个xml文件,我从Http Response接回来的也是一个xml.   
3. 下面假设你启动了一个tomcat,建立一个servlet. 从浏览器端发过来了一段xml代码段,这个代码段呢包含了两个东西.  
  1) 你所要调用的后台哪个方法.  
  2) 你所要调用方法的参数.  
 正如我们之前所说的,我们并没有存在一个全局的struts-config.xml文件来描述什么样的url该调用什么样的method,那么我们就需要把这些信息包含在我们的xml里.  
4. 当我们的servlet接收到这个xml包的时候,他就需要解析这个xml文件,分析出他所要调用的Java method,然后把这些参数传递传给这个方法,调用这个方法,获取到结果. 然后呢,我们需要重新把这个结果呢组装成xml的格式,用Http Response发给客户端.  
5. 客户端拿到这个Http Response的xml结果,他也可以解析这段xml,然后来取得到结果.   
以前上,就是最最基本的xml-rpc.  
  
说着说着,感觉这个调用过程很象Ajax的调用过程.回顾下Ajax的调用过程.  
1) 通过xmlHttpRequest发送一段xml(一般来说这个xml就是一些要调用方法的参数),发送到一个url,这个url可以是一个jsp,也可以是一个servlet. 然后就分析这段xml,并且调用方法,通过xmlHttpResponse的方法返回一段xml给刚刚的客户端.  
2) 客户端拿到这个xml后(或者更轻量级的json格式的数据),分析数据,然后通过javascript的方法来更改页面Html的内容.  
  
观察下，我们可以看出来主要的区别在于一般来说Ajax的xml是只包含调用的参数,不包含具体调用哪个方法的信息.(当然了,你说也可以那么做，我说的是大多数情况下.)..  
  
再回到我们刚刚说讲的最简单的xml-rpc.你看到这可能会说.这怎么会是xml-rpc,跟书上写的,都不一样..我这里所说的是最基本的.其实很多东西都是我们慢慢演化来的.  
  
我以前说过,web service这东西主要是为了application和application之间沟通,并不象我们刚刚最早说B/S模式访问. 那么,既然是application -> application,就必须存在着编程语言. 而且我们这个时候也不能管这两台机器一台叫client,一台叫server,因为他们是并级的.有可能application1 -> application2 -> application1. 所以,这个时候,我们给它起了个名字叫做Endpoint.  
在这里,我假设这两个application刚好用的都是Java语言.(因为我就对Java语言最熟悉 ;-) )... 好了,因为我们给Http Transport的都是xml,那么,怎么从我们Java参数对象 -> 我们所需要的xml文件呢? 于是乎,我们就有了JAXB,XmlBean的东西,这些东西主要就是负责从Java Object <-> Xml 之间的互转. 在web service的术语里,我们叫这个过程是marshall和unmarshall. 如果是用JAXB来负责Java Object <-> xml的,我们就说是data-binding的方式是jaxb.  
  
既然我们传给Transport的都是xml,我们需要对这个xml格式有个规定,也就是说,让client和server端他们懂得怎么去解析这个xml文件来获取到说要的调用方法以及调用方法的参数.. 于是就有了著名的SOAP规范..我们管这个xml的规范叫做binding. 比如有soap-binding, xml-binding等等.  
  
我们总结下从一个endpoint1到另外一个endpoint2的调用过程.  
1) 在endpoint1里, 通过JAXB把Java Parameter Object -> xml.  
2) 把这个xml -> SOAP规范的xml.  
3) 发送这个xml到endpoint2通过Transport.  
4) endpoint2接受到xml后,  
5) 根据SOAP的xml,解析出来需要调用的方法名,传过来的参数.  
6) 根据参数，方法名调用方法，获取到结果。  
7) 把结果通过JAXB unmarshall成为一个xml.  
8) 把xml变成一个SOAP规范的xml通过Transport传给endpoint1.  
9) endpoint1根据传递回来的xml,用JAXB unmarshall成 Java 对象,然后获取到所需要的结果.  
  
以上就是最简单的,最基本的,最核心的一个调用过程. 其他的功能都是基于这个core,做的.   
  
  
  
  

