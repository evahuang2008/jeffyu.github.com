--- 
layout: post
title: !binary |
  W0NYRl1DWEbkuK3nmoRPYnNlcnZlcuaooeW8j+W6lOeUqA==

published: true
meta: 
  spaces_a43755b404d273dfcedbd14ccb4f51ab_permalink: http://cid-04001c604af3f011.users.api.live.net/Users(288261576051650577)/Blogs('4001C604AF3F011!102')/Entries('4001C604AF3F011!450')?authkey=X13wC75MXT0%24
  _searchme: "1"
  _edit_last: "1"
  _efficient_related_posts: "a:8:{i:0;a:4:{s:2:\"ID\";s:1:\"6\";s:10:\"post_title\";s:53:\"[CXF]CXF\xE4\xB8\xAD\xE7\x9A\x84\xE4\xB8\xA4\xE4\xB8\xAA\xE6\xA6\x82\xE5\xBF\xB5:Invoker & PhaseInterceptor\";s:7:\"matches\";s:1:\"2\";s:9:\"permalink\";s:121:\"http://jeff.familyyu.net/2007/08/26/cxfcxf%e4%b8%ad%e7%9a%84%e4%b8%a4%e4%b8%aa%e6%a6%82%e5%bf%b5invoker-phaseinterceptor/\";}i:1;a:4:{s:2:\"ID\";s:2:\"10\";s:10:\"post_title\";s:61:\"[CXF]CXF\xE5\xBD\x93\xE4\xB8\xAD\xE7\x9A\x84Configuration -- Spring2.0\xE5\x8F\xAF\xE6\x89\xA9\xE5\xB1\x95XML\xE9\x85\x8D\xE7\xBD\xAE\";s:7:\"matches\";s:1:\"2\";s:9:\"permalink\";s:141:\"http://jeff.familyyu.net/2007/08/23/cxfcxf%e5%bd%93%e4%b8%ad%e7%9a%84configuration-spring2-0%e5%8f%af%e6%89%a9%e5%b1%95xml%e9%85%8d%e7%bd%ae/\";}i:2;a:4:{s:2:\"ID\";s:2:\"19\";s:10:\"post_title\";s:38:\"[CXF]CXF\xE4\xB8\xADDynamicProxy\xE6\xA8\xA1\xE5\xBC\x8F\xE7\x9A\x84\xE5\xBA\x94\xE7\x94\xA8\";s:7:\"matches\";s:1:\"2\";s:9:\"permalink\";s:109:\"http://jeff.familyyu.net/2007/07/15/cxfcxf%e4%b8%addynamicproxy%e6%a8%a1%e5%bc%8f%e7%9a%84%e5%ba%94%e7%94%a8/\";}i:3;a:4:{s:2:\"ID\";s:2:\"23\";s:10:\"post_title\";s:46:\"[CXF]CXF\xE4\xB8\xADCollection Parameter\xE6\xA8\xA1\xE5\xBC\x8F\xE7\x9A\x84\xE5\xBA\x94\xE7\x94\xA8\";s:7:\"matches\";s:1:\"2\";s:9:\"permalink\";s:117:\"http://jeff.familyyu.net/2007/07/14/cxfcxf%e4%b8%adcollection-parameter%e6%a8%a1%e5%bc%8f%e7%9a%84%e5%ba%94%e7%94%a8/\";}i:4;a:4:{s:2:\"ID\";s:2:\"22\";s:10:\"post_title\";s:42:\"[CXF]CXF\xE4\xB8\xAD\xE7\x9A\x84AbstractFactory\xE6\xA8\xA1\xE5\xBC\x8F\xE5\xBA\x94\xE7\x94\xA8.\";s:7:\"matches\";s:1:\"2\";s:9:\"permalink\";s:112:\"http://jeff.familyyu.net/2007/07/14/cxfcxf%e4%b8%ad%e7%9a%84abstractfactory%e6%a8%a1%e5%bc%8f%e5%ba%94%e7%94%a8/\";}i:5;a:4:{s:2:\"ID\";s:3:\"272\";s:10:\"post_title\";s:40:\"Apache CXF Web Service Development book.\";s:7:\"matches\";s:1:\"1\";s:9:\"permalink\";s:76:\"http://jeff.familyyu.net/2010/02/20/apache-cxf-web-service-development-book/\";}i:6;a:4:{s:2:\"ID\";s:3:\"167\";s:10:\"post_title\";s:30:\"IMS rolled out its 0.1 version\";s:7:\"matches\";s:1:\"1\";s:9:\"permalink\";s:67:\"http://jeff.familyyu.net/2007/11/13/ims-rolled-out-its-0-1-version/\";}i:7;a:4:{s:2:\"ID\";s:3:\"146\";s:10:\"post_title\";s:29:\"CXF ServiceInfo Model diagram\";s:7:\"matches\";s:1:\"1\";s:9:\"permalink\";s:66:\"http://jeff.familyyu.net/2007/09/06/cxf-serviceinfo-model-diagram/\";}}"
  _relation_threshold: "1"
tags: 
- Chinese
- CXF
- Design Patterns
- SOA
- Web Service
type: post
status: publish
---
<div id="msgcns!4001C604AF3F011!450" class="bvMsg">在CXF当中,其中在Transport这一层接收信息里,采用了Observer的模式,我记得我刚前段时间刚看这段代码的时候,
老感觉跟Observer模式对不上号...现在,我明白了,原来他是一个简化版的Observer模式.
先看下典型Observer模式&nbsp;
<ul>
	<li><span style="color: #aa0000;"><strong>Subject</strong></span><span style="color: #007733;"><strong> </strong></span>
<ul>
	<li>knows its observers. Any number of
Observer objects may observe a subject</li>
	<li>provides an interface for attaching and detaching Observer objects.</li>
</ul>
</li>
	<li><span style="color: #aa0000;"><strong>ConcreteSubject</strong></span><span style="color: #007733;"><strong> </strong></span>
<ul>
	<li>stores state of interest to
ConcreteObserver</li>
	<li>sends a notification to its observers when its state changes</li>
</ul>
</li>
	<li><span style="color: #aa0000;"><strong>Observer</strong></span><span style="color: #007733;"><strong> </strong></span>
<ul>
	<li>defines an updating interface for objects that should be notified of changes in a subject.</li>
</ul>
</li>
	<li><span style="color: #aa0000;"><strong>ConcreteObserver</strong></span> <span style="color: #007733;"> </span>
<ul>
	<li>maintains a reference to a
ConcreteSubject object</li>
	<li>stores state that should stay
consistent with the subject's</li>
	<li>implements the Observer updating interface to keep its state consistent
with the subject's</li>
</ul>
</li>
</ul>
在对号入座前,先讲讲我们解决的这个问题场景.
我们要通过Transport这一层来传送Message(消息),我们假设以HTTP传输协议来做例子.
在CXF当中,有两个概念来对Transport进行了封装.
1: Conduit 可以理解为信息发送地,发送一条信息需要经过两个步骤:
1) conduit.prepare(message);
2) conduit.close(message);
2: Destination 可以理解为目的地.

接下来,我们来看看是怎么应用Observer模式的.

Observable: (对应的是Subject)
public interface Observable {
void setMessageObserver(MessageObserver observer);
}

MessageObserver: (对应的是Observer)
public interface MessageObserver {
void onMessage(Message message);
}

Conduit/Destination (对应ConcreteSubject)
ClientImpl/ChainInitiationObserver (对应ConcreteObserver)

可以说,在CXF当中应用的Observer模式有点不一样.
1) 我们可以从Observable类中看出,他只能注册一个,以往典型的Subject是支持多于Observer注册的.
2) 我们不能在Subject中看到他调用Observer的方法.实际上呢,他是隐藏于ConcreteSubject类当中.
这里我们来看一个ConcreteSubject( ServletDestination )
protected void doMessage(MessageImpl inMessage) throws IOException {
try {
setHeaders(inMessage);
inMessage.setDestination(this);
incomingObserver.onMessage(inMessage);
} finally {
if (LOG.isLoggable(Level.FINE)) {
LOG.fine("Finished servicing http request on thread: " + Thread.currentThread());
}
}
}

当你读CXF的源代码的时候,你会发现尽管Conduit也支持Observable,但是目前代码出好像还没有具体的应用.
其实这是一个简单版本的Observer模式,而且并不是一个one-to-many,而是one-to-one的.
-----------------------
参考文档:
<a href="http://www.dofactory.com/Patterns/PatternObserver.aspx">http://www.dofactory.com/Patterns/PatternObserver.aspx</a>

</div>
